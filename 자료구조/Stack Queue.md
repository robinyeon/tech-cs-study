# Stack & Queue

<br/>

# 연다은봄

## 핵심 함수
\- 삽입(Push): 데이터를 삽입한다.       
\- 삭제(Pop): 데이터를 삭제한다.       

## Stack
![](https://user-images.githubusercontent.com/85475577/201534276-2e775d5f-8d22-489d-a193-28792e877e99.png) 

### 핵심 개념
\- 박스 쌓기에 비유: 아래에서부터 위로 차곡차곡 쌓는다.        
\- 선입후출(First-In-Last-Out), 후입선출(Last-In-First-Out)         

## Queue
![](https://user-images.githubusercontent.com/85475577/201534845-886c10c6-a63f-4c7e-a466-ba0f0d8e8091.png)      

### 핵심 개념
\- 대기 줄에 비유: 먼저 온 사람이 먼저 들어간다.          
\- 선입선출(First-In-First-Out)         

## 유의사항
\- 오버플로: 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생(저장 공간을 벗어나 데이터가 넘쳐흐를 때 발생)        
\- 언더플로: 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로가 발생      

<br/>

---

<br/>

# 황현성

## 🌟 선형 자료 구조

선형 자료 구조는 데이터 요소가 순차적으로 또는 선형적으로 배열되어 있는 데이터 구조이다.
각각의 모든 요소가 이전 및 다음 인접 요소에 연결되는 방식이다.
대표적인 선형 자료 구조에는 스택, 큐, 데크, 어레이, 리스트 등이 있다.

## 🍘 Stack

![002](https://user-images.githubusercontent.com/81323697/200262482-44e53974-dfd8-4e28-bd69-846d2d287595.png)

스택은 선입후출(First-In, Last-Out) 방식의 자료구조다. 그림으로 볼 수 있듯이 데이터의 삽입과 삭제는 한 쪽 방향에서 이루어진다. 
스택에서는 Top이라는 포인터가 있어 가장 최근의 데이터, 즉 가장 최근에 삽입되거나 가장 먼저 삭제될 데이터를 가리킨다.
데이터가 계속 삽입되어 Top이 스택의 Size를 초과할 경우 스택 오버플로우가 발생하고,
데이터가 계속 삭제되어 Top이 0 미만이 될 경우 스택 언더플로우가 발생한다.

## 🍮 Stack의 활용
- 재귀 알고리즘
- 총의 탄창

## 🍭 Stack의 장단점
- 삽입 삭제 시 Top의 위치만 확인하면 된다. 즉 시간 복잡도가 O(1)으로 삽입, 삭제, 조회 속도가 빠르다.
- Top이 가리키는 요소 외의 데이터에 접근할 수 없다.

## 🍏 Queue

![큐-001](https://user-images.githubusercontent.com/81323697/200258225-836f7c50-cc7a-4429-9c8c-c0c034df5a46.png)

큐는 선입선출(First-In, First-Out) 방식을 가진다. 먼저 삽입된 데이터는 먼저 삭제된다. 
가장 나중에 삽입된 요소를 가리키는 front와 가장 최근에 삽입된 요소를 가리키는 rear가 존재한다.


## 🍠 Queue의 활용
- 프린트 대기열
- 프로세스 스케줄링의 job queue

## 🍐 Queue의 장단점
- 삽입, 삭제 시 front와 rear의 위치만 확인하면 된다. 즉 시간 복잡도가 O(1)으로 삽입, 삭제, 조회 속도가 빠르다.
- front와 rear가 가리키는 요소 외의 데이터에 접근할 수 없다.
